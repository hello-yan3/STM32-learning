### USER
以下注释翻译为中文



### ASSISTANT
以下是注释的中文翻译：

```C
/**
  ******************************************************************************
  * @文件    stm32f1xx_hal_can.c
  * @作者    MCD Application Team
  * @简述    CAN HAL模块驱动程序。
  *          本文件提供了以下功能的固件函数，用于管理控制器局域网（CAN）外设：
  *           + 初始化和反初始化函数
  *           + 配置函数
  *           + 控制函数
  *           + 中断管理
  *           + 回调函数
  *           + 外设状态和错误函数
  *
  @verbatim
  ==============================================================================
                        ##### 如何使用此驱动程序 #####
  ==============================================================================
    [..]
      (#) 通过实现 HAL_CAN_MspInit() 来初始化CAN底层资源：
         (++) 使用 __HAL_RCC_CANx_CLK_ENABLE() 启用CAN接口时钟
         (++) 配置CAN引脚
             (+++) 启用CAN GPIO的时钟
             (+++) 将CAN引脚配置为开漏输出的复用功能
         (++) 如果使用中断（例如 HAL_CAN_ActivateNotification()）
             (+++) 使用 HAL_NVIC_SetPriority() 配置CAN中断优先级
             (+++) 使用 HAL_NVIC_EnableIRQ() 启用CAN中断处理程序
             (+++) 在CAN中断处理程序中，调用 HAL_CAN_IRQHandler()
      (#) 使用 HAL_CAN_Init() 函数初始化CAN外设。该函数依赖 HAL_CAN_MspInit() 进行底层初始化。
      (#) 使用以下配置函数配置接收过滤器：
            (++) HAL_CAN_ConfigFilter()
      (#) 使用 HAL_CAN_Start() 函数启动CAN模块。在此级别上，
          节点在总线上处于活动状态：它可以接收消息，并可以发送消息。
      (#) 管理消息发送时，可以使用以下发送控制函数：
            (++) HAL_CAN_AddTxMessage() 请求发送新消息。
            (++) HAL_CAN_AbortTxRequest() 中止挂起消息的发送请求。
            (++) HAL_CAN_GetTxMailboxesFreeLevel() 获取空闲发送邮箱的数量。
            (++) HAL_CAN_IsTxMessagePending() 检查是否有消息在发送邮箱中挂起。
            (++) HAL_CAN_GetTxTimestamp() 获取发送消息的时间戳（如果启用了时间触发通信模式）。
      (#) 当消息被接收到CAN接收FIFO时，可以使用 HAL_CAN_GetRxMessage() 函数检索它。
          函数 HAL_CAN_GetRxFifoFillLevel() 可以用来查看接收FIFO中有多少条消息。
      (#) 调用 HAL_CAN_Stop() 函数停止CAN模块。
      (#) 反初始化通过 HAL_CAN_DeInit() 函数完成。
      *** 轮询模式操作 ***
      ==============================
    [..]
      (#) 接收：
            (++) 使用 HAL_CAN_GetRxFifoFillLevel() 监控消息的接收，
                 直到至少接收到一条消息。
            (++) 然后使用 HAL_CAN_GetRxMessage() 获取消息。
      (#) 发送：
            (++) 使用 HAL_CAN_GetTxMailboxesFreeLevel() 监控发送邮箱的可用性，
                 直到至少有一个发送邮箱空闲。
            (++) 然后使用 HAL_CAN_AddTxMessage() 请求发送消息。
      *** 中断模式操作 ***
      ================================
    [..]
      (#) 使用 HAL_CAN_ActivateNotification() 函数激活通知。
          然后可以通过可用的用户回调函数 HAL_CAN_xxxCallback() 控制流程，
          使用相同的 API HAL_CAN_GetRxMessage() 和 HAL_CAN_AddTxMessage()。
      (#) 使用 HAL_CAN_DeactivateNotification() 函数可以停用通知。
      (#) 对于 CAN_IT_RX_FIFO0_MSG_PENDING 和 CAN_IT_RX_FIFO1_MSG_PENDING 通知需要特别注意。
          这些通知会触发回调函数 HAL_CAN_RxFIFO0MsgPendingCallback() 和
          HAL_CAN_RxFIFO1MsgPendingCallback()。用户有两种可能的选择：
            (++) 直接在回调函数中使用 HAL_CAN_GetRxMessage() 获取接收消息。
            (++) 或者在回调中停用通知而不获取接收消息。然后可以在稍后使用
                 HAL_CAN_GetRxMessage() 获取接收消息。一旦读取消息，可以重新激活通知。
      *** 睡眠模式 ***
      ==================
    [..]
      (#) 使用 HAL_CAN_RequestSleep() 函数将CAN外设置于睡眠模式（低功耗）。
          睡眠模式将在当前CAN活动（发送或接收CAN帧）完成后进入。
      (#) 可以激活通知以被告知何时进入睡眠模式。
      (#) 使用 HAL_CAN_IsSleepActive() 检查是否已进入睡眠模式。
          注意，CAN状态（可通过 API HAL_CAN_GetState() 获取）在提交睡眠模式请求后
          （尚未进入睡眠模式）为 HAL_CAN_STATE_SLEEP_PENDING，
          并在睡眠模式生效时变为 HAL_CAN_STATE_SLEEP_ACTIVE。
      (#) 唤醒睡眠模式可以通过两种方式触发：
            (++) 使用 HAL_CAN_WakeUp()。当从该函数返回时，
                 如果返回状态为 HAL_OK，则表示已退出睡眠模式。
            (++) 当CAN外设检测到接收CAN帧的起始信号时，
                 如果启用了自动唤醒模式。
  *** 回调注册 ***
  =============================================
  编译定义 USE_HAL_CAN_REGISTER_CALLBACKS 设置为 1 时，
  允许用户动态配置驱动程序回调。
  使用函数 @ref HAL_CAN_RegisterCallback() 注册中断回调。
  函数 @ref HAL_CAN_RegisterCallback() 允许注册以下回调：
    (+) TxMailbox0CompleteCallback   : 发送邮箱 0 完成回调。
    (+) TxMailbox1CompleteCallback   : 发送邮箱 1 完成回调。
    (+) TxMailbox2CompleteCallback   : 发送邮箱 2 完成回调。
    (+) TxMailbox0AbortCallback      : 发送邮箱 0 中止回调。
    (+) TxMailbox1AbortCallback      : 发送邮箱 1 中止回调。
    (+) TxMailbox2AbortCallback      : 发送邮箱 2 中止回调。
    (+) RxFifo0MsgPendingCallback    : 接收 FIFO 0 消息挂起回调。
    (+) RxFifo0FullCallback          : 接收 FIFO 0 满回调。
    (+) RxFifo1MsgPendingCallback    : 接收 FIFO 1 消息挂起回调。
    (+) RxFifo1FullCallback          : 接收 FIFO 1 满回调。
    (+) SleepCallback                : 睡眠回调。
    (+) WakeUpFromRxMsgCallback      : 从接收消息唤醒回调。
    (+) ErrorCallback                : 错误回调。
    (+) MspInitCallback              : CAN MspInit。
    (+) MspDeInitCallback            : CAN MspDeInit。
  此函数的参数包括 HAL 外设句柄、回调 ID 和指向用户回调函数的指针。
  使用函数 @ref HAL_CAN_UnRegisterCallback() 将回调重置为默认弱函数。
  @ref HAL_CAN_UnRegisterCallback 的参数包括 HAL 外设句柄和回调 ID。
  此函数允许重置以下回调：
    (+) TxMailbox0CompleteCallback   : 发送邮箱 0 完成回调。
    (+) TxMailbox1CompleteCallback   : 发送邮箱 1 完成回调。
    (+) TxMailbox2CompleteCallback   : 发送邮箱 2 完成回调。
    (+) TxMailbox0AbortCallback      : 发送邮箱 0 中止回调。
    (+) TxMailbox1AbortCallback      : 发送邮箱 1 中止回调。
    (+) TxMailbox2AbortCallback      : 发送邮箱 2 中止回调。
    (+) RxFifo0MsgPendingCallback    : 接收 FIFO 0 消息挂起回调。
    (+) RxFifo0FullCallback          : 接收 FIFO 0 满回调。
    (+) RxFifo1MsgPendingCallback    : 接收 FIFO 1 消息挂起回调。
    (+) RxFifo1FullCallback          : 接收 FIFO 1 满回调。
    (+) SleepCallback                : 睡眠回调。
    (+) WakeUpFromRxMsgCallback      : 从接收消息唤醒回调。
    (+) ErrorCallback                : 错误回调。
    (+) MspInitCallback              : CAN MspInit。
    (+) MspDeInitCallback            : CAN MspDeInit。
  默认情况下，在执行 @ref HAL_CAN_Init() 且状态为 HAL_CAN_STATE_RESET 后，
  所有回调都被设置为对应的弱函数：
  示例 @ref HAL_CAN_ErrorCallback()。
  但 MspInit 和 MspDeInit 函数例外，它们在 @ref HAL_CAN_Init()/ @ref HAL_CAN_DeInit() 
  中被重置为旧的弱函数，仅当这些回调为空（未事先注册）时。
  如果 MspInit 或 MspDeInit 不为空，则 @ref HAL_CAN_Init()/ @ref HAL_CAN_DeInit() 
  保留并使用用户 MspInit/MspDeInit 回调（之前已注册）。
  回调只能在 HAL_CAN_STATE_READY 状态下注册/注销。
  但 MspInit/MspDeInit 是例外，它们可以在 HAL_CAN_STATE_READY 或 HAL_CAN_STATE_RESET 
  状态下注册/注销，因此可以在初始化/反初始化期间使用注册的（用户）MspInit/DeInit 回调。
  在这种情况下，首先使用 @ref HAL_CAN_RegisterCallback() 注册 MspInit/MspDeInit 用户回调，
  然后再调用 @ref HAL_CAN_DeInit() 或 @ref HAL_CAN_Init() 函数。
  当编译定义 USE_HAL_CAN_REGISTER_CALLBACKS 设置为 0 或未定义时，
  回调注册功能不可用，所有回调都被设置为对应的弱函数。
  @endverbatim
  ******************************************************************************
  * @注意事项
  *
  * <h2><center>&copy; 版权 (c) 2016 STMicroelectronics.
  * 保留所有权利。</center></h2>
  *
  * 本软件组件由ST根据BSD 3-Clause许可授权，
  * "许可证"；除非遵守许可证，否则您不得使用本文件。
  * 您可以通过以下链接获取许可证副本：
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */
```
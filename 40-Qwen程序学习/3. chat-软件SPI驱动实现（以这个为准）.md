# USER——软件SPI
实现软件SPI，软件SPI需要支持4种模式（CPOL=0或1，CPHA=0或1），
其中，使用#define 方式，在头文件中定义CPOL/CPHA值，
在驱动程序中，使用#if / #elif  /#else 等方式，实现不同模式切换，

此外，在写完相应驱动程序后，补充一些示例程序；另外，对于相应的程序，遵循doxygen注释规范，标记相应注释；

补充：CS/MOSI/MISO/SCLK引脚已配置且连接好；

### ASSISTANT
<think>
好的，我现在需要实现一个软件SPI驱动，支持四种模式，也就是CPOL和CPHA的不同组合。首先，我得理解这四个模式的区别。CPOL是时钟极性，CPHA是时钟相位。CPOL为0时，空闲时钟是低电平，为1则是高电平。CPHA为0时，数据在第一个时钟边沿采样，而CPHA为1时在第二个边沿采样。所以四个模式分别是：

模式0：CPOL=0，CPHA=0
模式1：CPOL=0，CPHA=1
模式2：CPOL=1，CPHA=0
模式3：CPOL=1，CPHA=1

接下来，用户要求使用#define在头文件中定义CPOL和CPHA的值，然后在驱动程序中通过预处理指令来切换不同的模式。所以，我需要先创建一个头文件，比如software_spi.h，里面用#define来设置CPOL和CPHA的值。例如：

#define SPI_CPOL 0
#define SPI_CPHA 0

然后在驱动程序中，根据这两个宏的值，用#if、#elif来判断当前模式，并实现对应的时序。

接下来，我需要考虑如何用GPIO模拟SPI的时序。SPI的基本操作包括控制SCLK、MOSI，读取MISO。每个模式的时钟相位和极性不同，所以发送和接收数据的函数需要根据模式调整时钟的高低电平以及采样时机。

比如，在模式0（CPOL=0，CPHA=0）的情况下，时钟空闲是低电平，数据在上升沿被采样。所以在发送数据时，可能需要先拉低时钟，然后设置MOSI的值，在上升沿发送数据，然后在下降沿可能采样MISO？

或者可能需要更仔细的分析。例如，对于CPHA=0的情况，数据在第一个边沿（可能是上升或下降，取决于CPOL）被采样。例如，模式0的CPOL=0，CPHA=0，数据在时钟的上升沿被采样，而模式1的CPHA=1，数据在下降沿被采样。或者可能需要更仔细地查阅SPI时序图。

比如，模式0：CPOL=0，CPHA=0。时钟空闲为低电平。数据在时钟的第一个边沿（上升沿）被采样，第二个边沿（下降沿）数据被设置。或者可能相反？

可能我需要明确每个模式的时序。例如，根据维基百科的SPI模式描述：

Mode 0 (CPOL=0, CPHA=0): Clock starts low, data is sampled on the rising edge and changed on the falling edge.

Mode 1 (CPOL=0, CPHA=1): Clock starts low, data is sampled on the falling edge and changed on the rising edge.

Mode 2 (CPOL=1, CPHA=0): Clock starts high, data is sampled on the falling edge and changed on the rising edge.

Mode 3 (CPOL=1, CPHA=1): Clock starts high, data is sampled on the rising edge and changed on the falling edge.

或者可能需要更仔细的确认。比如，在CPOL=0的情况下，SCLK空闲是低电平。当CPHA=0时，数据在第一个边沿（上升沿）被采样，第二个边沿（下降沿）数据被设置。而CPHA=1时，数据在第二个边沿（下降沿）被采样，第一个边沿（上升沿）数据被设置？

或者可能，对于每个SPI模式，数据的采样和设置时机不同。例如，在模式0，当SCLK从低到高（上升沿）时，主设备采样数据，而数据在SCLK的下降沿被改变。或者可能，主设备在时钟的某个边沿输出数据，从设备在另一个边沿采样？

这部分可能需要更仔细的时序分析。例如，对于模式0（CPOL=0，CPHA=0），数据在时钟的上升沿被采样，下降沿被设置。或者相反？

假设模式0的时序是：SCLK空闲为低。在第一个时钟周期的上升沿，主设备将数据放到MOSI线上，从设备在此时采样数据。然后在下降沿，主设备可能改变数据线的状态，准备下一个bit。

或者，可能主设备在SCLK的上升沿改变数据，而从设备在下降沿采样？这可能需要根据具体的时序图来确认。

比如，根据一些资料，当CPHA=0时，数据在第一个时钟边沿被采样，而CPHA=1时在第二个边沿被采样。这里的“第一个”和“第二个”指的是每个时钟周期中的第一个边沿和第二个边沿。例如，在CPOL=0的情况下，每个时钟周期是低到高再到低。所以第一个边沿是上升沿，第二个是下降沿。在CPHA=0的情况下，数据在上升沿被采样，而CPHA=1则在下降沿被采样。

同样，当CPOL=1时，时钟空闲为高，每个周期是高到低再到高。所以第一个边沿是下降沿，第二个是上升沿。CPHA=0时，数据在下降沿采样，CPHA=1时在上升沿采样。

所以，对于发送一个bit，主设备需要在正确的时钟边沿改变数据线的状态，而从设备在对应的边沿采样数据。

例如，在模式0（CPOL=0，CPHA=0）的情况下，主设备在SCLK的上升沿将数据线设置为下一个bit的值，而从设备在上升沿采样数据。或者，可能主设备在SCLK的上升沿之前设置数据，然后在上升沿时从设备采样。这可能需要更详细的时序分析。

假设在发送一个字节时，每个bit的传输过程如下：

对于模式0（CPOL=0，CPHA=0）：

- SCLK初始状态为低。
- 主设备将MOSI设置为要发送的bit。
- 将SCLK拉高，此时从设备在上升沿采样数据。
- 将SCLK拉低，准备发送下一个bit。

或者，可能主设备在拉高SCLK之前设置数据，然后在拉高之后，从设备采样。然后在拉低SCLK之后，主设备改变数据线的状态，为下一个bit做准备。

或者，可能顺序是这样的：

1. 设置MOSI的值。
2. 产生一个时钟脉冲（例如，从低到高再到低）。
3. 在时钟的上升沿，从设备采样数据。

所以，对于每个bit，主设备需要先设置MOSI，然后生成一个时钟脉冲。例如，在模式0的情况下：

- SCLK初始为低。
- 设置MOSI的值。
- 将SCLK拉高（此时从设备在上升沿采样）。
- 将SCLK拉低，进入下一个bit的处理。

如果是这样，那么对于每个bit的发送，顺序是设置数据，然后产生一个时钟脉冲。

对于接收数据，主设备在时钟的某个边沿读取MISO的值。例如，在模式0的情况下，主设备在SCLK的上升沿之后，下降沿之前读取MISO的值？或者是在上升沿的时候同时读取？

可能需要更明确的步骤。例如，在发送一个bit时，主设备同时接收一个bit。所以，在发送数据的同时，需要在正确的时钟边沿读取MISO的值。

例如，在模式0的情况下，主设备在SCLK的上升沿将MOSI的值发送出去，同时在该上升沿之后，从设备将数据放到MISO线上，主设备在下降沿读取该数据？或者主设备在上升沿之后的某个时间点读取？

这可能比较复杂。可能需要针对每个模式，明确发送和接收的时序。

假设对于每个模式，发送和接收的时序如下：

模式0（CPOL=0，CPHA=0）：

- SCLK空闲为低。
- 数据在SCLK的上升沿被采样（主设备发送数据，从设备采样）。
- 数据在SCLK的下降沿被改变（主设备设置下一个数据位）。

所以，发送一个bit的步骤：

1. 将MOSI设置为要发送的bit。
2. 拉高SCLK，此时从设备在上升沿采样。
3. 拉低SCLK，准备发送下一个bit。

同时，在发送数据的同时，主设备需要在某个边沿读取MISO的值。例如，在SCLK的上升沿之后，下降沿之前，主设备读取MISO的值？或者在下降沿之后？

可能，主设备在发送数据的同时，需要在SCLK的上升沿之后，下降沿之前读取MISO的值，因为此时从设备可能已经将数据稳定在MISO线上。

或者，可能主设备在SCLK的下降沿读取MISO的值？

这部分可能需要更仔细的分析。例如，在模式0的情况下，主设备在SCLK的上升沿之后，下降沿之前，读取MISO的值。或者，在下降沿之后？

假设在发送每个bit时，主设备在设置MOSI之后，拉高SCLK，此时从设备采样MOSI的数据。同时，主设备在SCLK的上升沿之后，下降沿之前，读取MISO的值，因为此时从设备可能已经将数据稳定在MISO线上。

或者，可能主设备在SCLK的下降沿之后读取MISO的值？

这可能需要参考具体的SPI时序图。例如，在模式0的情况下，主设备在SCLK的上升沿将数据发送到MOSI，同时从设备在该上升沿采样数据。而主设备在SCLK的下降沿之后读取MISO的数据，因为从设备可能在下降沿之后将数据准备好。

或者，可能主设备在发送数据后，在SCLK的下降沿之后读取MISO的数据？

这可能需要根据具体的SPI模式来确定。

例如，根据一些资料，当CPHA=0时，数据在第一个边沿（上升沿或下降沿，取决于CPOL）被采样，而数据在第二个边沿被设置。例如，在模式0（CPOL=0，CPHA=0），数据在上升沿被采样，在下降沿被设置。因此，主设备在发送数据时，先设置MOSI，然后拉高SCLK（上升沿，从设备采样），然后拉低SCLK（下降沿，主设备设置下一个bit的数据）。同时，主设备在SCLK的上升沿之后，下降沿之前读取MISO的数据？

或者，主设备在发送数据的同时，读取MISO的数据。例如，在发送一个字节时，每个bit的发送和接收是同时进行的。所以，在发送每个bit时，主设备在设置MOSI之后，拉高SCLK，此时从设备采样MOSI的数据，同时主设备在SCLK的上升沿之后，下降沿之前读取MISO的数据？

或者，主设备在SCLK的下降沿之后读取MISO的数据？

这部分可能需要更详细的分析。例如，在模式0的情况下，主设备在发送数据时，在SCLK的上升沿将数据发送到MOSI，同时从设备在该上升沿采样。主设备在发送数据后，在SCLK的下降沿之后，读取MISO的数据，因为此时从设备可能在下降沿之后将数据准备好。

或者，可能主设备在发送数据后，在SCLK的下降沿之前读取MISO的数据？

这可能需要参考具体的时序图。例如，在模式0的情况下，主设备在SCLK的上升沿发送数据，从设备在该上升沿采样。主设备在发送数据后，在SCLK的下降沿之后，读取MISO的数据，因为此时从设备可能在下降沿之后将数据放到MISO线上。

假设在发送每个bit时，主设备执行以下步骤：

1. 设置MOSI的值为当前要发送的bit。
2. 拉高SCLK，此时从设备在上升沿采样MOSI的数据。
3. 读取MISO的值（此时可能需要在上升沿之后，下降沿之前读取）。
4. 拉低SCLK，准备发送下一个bit。

或者，步骤3可能在拉低SCLK之后？

这可能因不同的模式而异。例如，在模式0的情况下，主设备在拉高SCLK之后，读取MISO的数据，然后在拉低SCLK之前或之后？

或者，可能在拉高SCLK之后，主设备立即读取MISO的数据，然后在拉低SCLK之前？

这部分可能需要更仔细的考虑。

假设在模式0的情况下，主设备在拉高SCLK之后，立即读取MISO的数据，然后在拉低SCLK之前。这样，数据在上升沿被采样，主设备在上升沿之后读取。

或者，可能在拉高SCLK之后，主设备等待一段时间，让从设备有时间将数据放到MISO线上，然后读取。

这可能涉及到延时的问题，但软件SPI可能需要插入一些nop操作或者延时函数来确保时序正确。

现在，回到代码实现。假设每个bit的发送和接收过程需要根据不同的模式调整时钟的高低电平和数据的采样时机。

例如，在模式0的情况下：

- SCLK初始为低。
- 设置MOSI。
- 拉高SCLK，此时从设备采样数据。
- 读取MISO。
- 拉低SCLK，进入下一个bit。

对于模式1（CPOL=0，CPHA=1）：

- SCLK初始为低。
- 拉高SCLK，此时可能数据在下降沿被采样？
或者，可能模式1的CPHA=1，数据在第二个边沿被采样。例如，在模式1的情况下，SCLK的初始为低，第一个边沿是上升沿，第二个是下降沿。CPHA=1时，数据在下降沿被采样。所以，主设备在发送数据时，可能在下降沿采样，而数据在上升沿被设置？

这可能比较复杂。例如，在模式1的情况下：

- SCLK初始为低。
- 主设备将MOSI设置为当前bit。
- 拉高SCLK（此时可能没有采样）。
- 拉低SCLK，此时从设备在下降沿采样数据。
- 读取MISO的数据。

或者，主设备在拉低SCLK之后读取MISO的数据？

这可能需要更详细的时序分析。

现在，我需要为每个模式编写对应的发送和接收函数。或者，可以编写一个统一的函数，根据CPOL和CPHA的值，调整时钟的高低电平和数据的采样时机。

例如，在发送一个字节的函数中，每个bit的处理可能如下：

for (每个bit) {
    设置MOSI的值；
    生成时钟脉冲；
    读取MISO的值；
}

生成时钟脉冲的部分需要根据不同的模式来调整时钟的高低电平和采样时机。

例如，在模式0的情况下，生成时钟脉冲的步骤是：

拉高SCLK；
读取MISO；
拉低SCLK；

在模式1的情况下：

拉高SCLK；
拉低SCLK；
读取MISO；

或者，可能顺序不同？

这可能取决于CPHA的值。例如，当CPHA=0时，数据在第一个边沿采样（上升沿或下降沿，取决于CPOL），而当CPHA=1时，数据在第二个边沿采样。

因此，对于每个模式，需要确定时钟脉冲的生成顺序和数据采样的时机。

例如，模式0（CPOL=0，CPHA=0）：

- 时钟初始为低。
- 设置MOSI。
- 拉高SCLK（上升沿，从设备采样）。
- 读取MISO。
- 拉低SCLK。

模式1（CPOL=0，CPHA=1）：

- 时钟初始为低。
- 设置MOSI。
- 拉高SCLK。
- 拉低SCLK（下降沿，从设备采样）。
- 读取MISO。

模式2（CPOL=1，CPHA=0）：

- 时钟初始为高。
- 设置MOSI。
- 拉低SCLK（下降沿，从设备采样）。
- 读取MISO。
- 拉高SCLK。

模式3（CPOL=1，CPHA=1）：

- 时钟初始为高。
- 设置MOSI。
- 拉低SCLK。
- 拉高SCLK（上升沿，从设备采样）。
- 读取MISO。

或者，可能顺序不同？

例如，对于模式3（CPOL=1，CPHA=1），时钟初始为高。CPHA=1意味着数据在第二个边沿采样。每个时钟周期有两个边沿：下降沿和上升沿。所以，第一个边沿是下降沿，第二个是上升沿。因此，在模式3中，数据在上升沿被采样。所以，主设备在发送数据时，可能需要：

- 设置MOSI。
- 拉低SCLK（下降沿，此时可能没有采样）。
- 拉高SCLK（上升沿，从设备采样）。
- 读取MISO。

这可能需要更仔细的分析。

现在，我需要将这些时序转换为代码。例如，在发送一个bit时，根据不同的模式，调整时钟的高低电平和数据的采样时机。

假设每个bit的处理如下：

对于每个bit in 0..7:

1. 设置MOSI的值（当前bit的最高位或最低位，取决于MSB或LSB优先）。
2. 生成时钟脉冲，根据模式调整时序。
3. 在正确的时钟边沿读取MISO的值。

例如，在模式0的情况下：

设置MOSI；
SCLK高；
读取MISO；
SCLK低；

在模式1的情况下：

设置MOSI；
SCLK高；
SCLK低；
读取MISO；

在模式2的情况下：

设置MOSI；
SCLK低；
读取MISO；
SCLK高；

在模式3的情况下：

设置MOSI；
SCLK低；
SCLK高；
读取MISO；

或者，可能顺序不同？

这可能需要根据每个模式的具体时序来确定。

现在，我需要将这些逻辑用条件编译的方式实现在代码中。例如，在发送一个字节的函数中，根据SPI_CPOL和SPI_CPHA的值，使用#if、#elif来选择不同的时序代码。

例如：

void SPI_Transfer(uint8_t data) {
    uint8_t received = 0;
    for (int i = 0; i < 8; i++) {
        // 设置MOSI
        if (data & (0x80 >> i)) { // 假设MSB优先
            MOSI_HIGH();
        } else {
            MOSI_LOW();
        }

        // 生成时钟脉冲
        #if (SPI_CPOL == 0 && SPI_CPHA == 0)
            SCLK_HIGH();
            // 读取MISO
            if (MISO_READ()) {
                received |= (0x80 >> i);
            }
            SCLK_LOW();
        #elif (SPI_CPOL == 0 && SPI_CPHA == 1)
            SCLK_HIGH();
            SCLK_LOW();
            // 读取MISO
            if (MISO_READ()) {
                received |= (0x80 >> i);
            }
        #elif (SPI_CPOL == 1 && SPI_CPHA == 0)
            SCLK_LOW();
            // 读取MISO
            if (MISO_READ()) {
                received |= (0x80 >> i);
            }
            SCLK_HIGH();
        #elif (SPI_CPOL == 1 && SPI_CPHA == 1)
            SCLK_LOW();
            SCLK_HIGH();
            // 读取MISO
            if (MISO_READ()) {
                received |= (0x80 >> i);
            }
        #endif
    }
    return received;
}

但这样写的话，每个模式的代码块可能重复较多。或者，可以将时钟脉冲的生成和数据采样分开处理。

例如，对于每个模式，确定时钟的初始状态，然后在发送每个bit时，根据模式调整时钟的高低电平和采样时机。

或者，可以将时钟脉冲的生成分为几个步骤：

1. 在发送数据前，设置时钟到空闲状态。
2. 根据CPHA的值，确定在时钟的第一个边沿还是第二个边沿采样数据。
3. 生成时钟脉冲，并在正确的边沿读取数据。

例如，在模式0（CPOL=0，CPHA=0）的情况下：

- 时钟空闲为低。
- 数据在第一个边沿（上升沿）被采样。
- 所以，发送数据时，设置MOSI，拉高时钟，采样MISO，拉低时钟。

在模式1（CPOL=0，CPHA=1）的情况下：

- 时钟空闲为低。
- 数据在第二个边沿（下降沿）被采样。
- 所以，发送数据时，设置MOSI，拉高时钟，拉低时钟（此时下降沿），采样MISO。

同样，其他模式类似。

现在，我需要将这些逻辑转化为代码，并使用预处理指令根据CPOL和CPHA的值选择正确的时序。

此外，还需要考虑时钟的初始状态。例如，当CPOL=1时，时钟初始为高，所以在初始化时，需要将SCLK设置为高电平。

例如，在初始化函数中：

void SPI_Init() {
    // 配置CS、MOSI、SCLK为输出，MISO为输入
    // ...
    #if (SPI_CPOL == 1)
        SCLK_HIGH();
    #else
        SCLK_LOW();
    #endif
}

这样，初始化时根据CPOL设置SCLK的初始电平。

接下来，在发送数据时，根据CPOL和CPHA的值，生成正确的时钟脉冲。

例如，在发送每个bit时：

设置MOSI的值；
根据CPHA的值，决定在哪个边沿采样数据。

例如，当CPHA=0时，数据在第一个边沿采样，当CPHA=1时，在第二个边沿采样。

对于CPOL=0的情况：

- 时钟空闲为低。
- 第一个边沿是上升沿，第二个是下降沿。

对于CPOL=1的情况：

- 时钟空闲为高。
- 第一个边沿是下降沿，第二个是上升沿。

所以，当CPHA=0时，数据在第一个边沿采样，当CPHA=1时，在第二个边沿采样。

因此，在代码中，可以将时钟脉冲的生成分为两个步骤：

1. 在第一个边沿，根据CPHA的值决定是否采样数据。
2. 在第二个边沿，根据CPHA的值决定是否采样数据。

或者，更简单的方式是，根据CPOL和CPHA的组合，生成对应的时钟脉冲。

例如，对于每个模式，时钟脉冲的顺序是不同的：

模式0（CPOL=0，CPHA=0）：

- 初始SCLK低。
- 设置MOSI。
- 拉高SCLK（上升沿，采样）。
- 读取MISO。
- 拉低SCLK。

模式1（CPOL=0，CPHA=1）：

- 初始SCLK低。
- 设置MOSI。
- 拉高SCLK（不采样）。
- 拉低SCLK（下降沿，采样）。
- 读取MISO。

模式2（CPOL=1，CPHA=0）：

- 初始SCLK高。
- 设置MOSI。
- 拉低SCLK（下降沿，采样）。
- 读取MISO。
- 拉高SCLK。

模式3（CPOL=1，CPHA=1）：

- 初始SCLK高。
- 设置MOSI。
- 拉低SCLK（不采样）。
- 拉高SCLK（上升沿，采样）。
- 读取MISO。

这样，每个模式的时钟脉冲顺序不同，但可以通过条件编译来处理。

现在，我需要将这些步骤转化为代码。例如，在发送每个bit时：

设置MOSI；
#if (SPI_CPOL == 0)
    #if (SPI_CPHA == 0)
        SCLK_HIGH();
        // 采样MISO
        received |= (MISO_READ() << (7 - i));
        SCLK_LOW();
    #else // CPHA=1
        SCLK_HIGH();
        SCLK_LOW();
        // 采样MISO
        received |= (MISO_READ() << (7 - i));
    #endif
#else // CPOL=1
    #if (SPI_CPHA == 0)
        SCLK_LOW();
        // 采样MISO
        received |= (MISO_READ() << (7 - i));
        SCLK_HIGH();
    #else // CPHA=1
        SCLK_LOW();
        SCLK_HIGH();
        // 采样MISO
        received |= (MISO_READ() << (7 - i));
    #endif
#endif

这样，每个模式的处理被分开处理。但这样写的话，代码会比较冗长，但可以确保每个模式的时序正确。

此外，需要注意的是，发送和接收是同时进行的，所以在发送一个字节的同时，会接收到一个字节的数据。因此，函数可能返回接收到的字节。

现在，我需要考虑如何将这些代码整合到驱动程序中，并添加Doxygen注释。

例如，在头文件software_spi.h中：

#ifndef SOFTWARE_SPI_H
#define SOFTWARE_SPI_H

#include <stdint.h>

// 定义SPI模式
#define SPI_CPOL 0
#define SPI_CPHA 0

// 引脚操作宏，需要用户根据实际硬件实现
#define CS_LOW()    // 拉低片选
#define CS_HIGH()   // 拉高片选
#define MOSI_LOW()  // 拉低MOSI
#define MOSI_HIGH() // 拉高MOSI
#define SCLK_LOW()  // 拉低SCLK
#define SCLK_HIGH() // 拉高SCLK
#define MISO_READ() (0) // 读取MISO引脚电平，返回0或非零

void SPI_Init(void);
uint8_t SPI_Transfer(uint8_t data);

#endif // SOFTWARE_SPI_H

在驱动文件software_spi.c中：

#include "software_spi.h"

void SPI_Init(void) {
    // 初始化GPIO引脚
    // 配置CS、MOSI、SCLK为输出，MISO为输入

    // 设置SCLK初始状态
#if (SPI_CPOL == 1)
    SCLK_HIGH();
#else
    SCLK_LOW();
#endif
}

/**
 * @brief 通过软件SPI传输一个字节，并接收一个字节
 * @param data 要发送的数据
 * @return 接收到的数据
 */
 uint8_t SPI_Transfer(uint8_t data) {
    uint8_t received = 0;
    for (int i = 0; i < 8; i++) {
        // 设置MOSI的值（MSB优先）
        if (data & (0x80 >> i)) {
            MOSI_HIGH();
        } else {
            MOSI_LOW();
        }

        // 生成时钟脉冲并采样MISO
 #if (SPI_CPOL == 0)
    #if (SPI_CPHA == 0)
        SCLK_HIGH();
        if (MISO_READ()) {
            received |= (0x80 >> i);
        }
        SCLK_LOW();
    #else // CPHA=1
        SCLK_HIGH();
        SCLK_LOW();
        if (MISO_READ()) {
            received |= (0x80 >> i);
        }
    #endif
 #else // CPOL=1
    #if (SPI_CPHA == 0)
        SCLK_LOW();
        if (MISO_READ()) {
            received |= (0x80 >> i);
        }
        SCLK_HIGH();
    #else // CPHA=1
        SCLK_LOW();
        SCLK_HIGH();
        if (MISO_READ()) {
            received |= (0x80 >> i);
        }
    #endif
 #endif
    }
    return received;
 }

这样，每个模式的时钟脉冲生成和数据采样都被正确处理。同时，使用了条件编译来根据CPOL和CPHA的值选择不同的代码块。

接下来，需要编写示例程序。例如，在main.c中：

#include "software_spi.h"

int main() {
    SPI_Init();
    
    // 示例：发送0x55并接收数据
    uint8_t received = SPI_Transfer(0x55);
    
    // 其他操作...
    
    return 0;
}

此外，需要确保用户根据实际的硬件配置引脚操作宏，比如替换MOSI_HIGH()等为具体的GPIO操作函数。

最后，添加Doxygen注释。例如，在SPI_Transfer函数中，添加@param和@return的注释，如上面的代码所示。

现在，检查代码是否正确。例如，在模式0的情况下，每个bit的发送和接收是否正确：

设置MOSI，拉高SCLK，读取MISO，拉低SCLK。这样，数据在上升沿被发送，从设备在上升沿采样，主设备在上升沿之后读取MISO的值。

对于模式1（CPOL=0，CPHA=1）：

设置MOSI，拉高SCLK，拉低SCLK，读取MISO。此时，数据在下降沿被采样，所以主设备在拉低SCLK之后读取MISO的值。

这样，代码的时序是否正确？

可能需要进一步验证。例如，在模式1的情况下，从设备在下降沿采样数据。主设备在发送数据后，在下降沿之后读取MISO的值。因此，代码中的处理是正确的。

同样，其他模式的处理是否正确？

例如，模式2（CPOL=1，CPHA=0）：

设置MOSI，拉低SCLK（下降沿，从设备采样），读取MISO，拉高SCLK。这样，数据在下降沿被采样，主设备在下降沿之后读取MISO的值。

模式3（CPOL=1，CPHA=1）：

设置MOSI，拉低SCLK，拉高SCLK（上升沿，从设备采样），读取MISO。这样，数据在上升沿被采样，主设备在上升沿之后读取MISO的值。

这样，每个模式的处理是正确的。

最后，示例程序可能需要更多的内容，比如发送多个字节，或者与具体的设备通信。例如，读取一个SPI设备的寄存器：

void example_read_register() {
    CS_LOW();
    SPI_Transfer(0x03); // 假设指令是读取寄存器
    uint8_t reg_value = SPI_Transfer(0xFF); // 发送哑数据，接收寄存器值
    CS_HIGH();
}

这样的示例可以展示如何使用SPI_Transfer函数进行通信。

总结，通过条件编译处理不同的SPI模式，并确保每个模式的时钟脉冲和数据采样时机正确。同时，添加必要的注释和示例程序，方便用户理解和使用。
</think>

————————————————————————————————

-----

————————————————————————————————

### 正文

为了实现支持四种模式的软件SPI驱动，我们首先在头文件中定义CPOL和CPHA的值，然后在驱动程序中使用条件编译处理不同的时序逻辑。以下是完整的代码实现：

### 头文件 `software_spi.h`
```c
#ifndef SOFTWARE_SPI_H
#define SOFTWARE_SPI_H

#include <stdint.h>

// 定义SPI模式（CPOL和CPHA）
#define SPI_CPOL 0  /**< 时钟极性：0-空闲低电平，1-空闲高电平 */
#define SPI_CPHA 0  /**< 时钟相位：0-数据在第一个边沿采样，1-数据在第二个边沿采样 */

// 引脚操作宏（需根据实际硬件实现）
#define CS_LOW()    /**< 拉低片选信号 */
#define CS_HIGH()   /**< 拉高片选信号 */
#define MOSI_LOW()  /**< 拉低MOSI引脚 */
#define MOSI_HIGH() /**< 拉高MOSI引脚 */
#define SCLK_LOW()  /**< 拉低SCLK引脚 */
#define SCLK_HIGH() /**< 拉高SCLK引脚 */
#define MISO_READ() (0) /**< 读取MISO引脚电平，返回0或非零值 */

#ifdef __cplusplus
extern "C" {
#endif

void SPI_Init(void);
uint8_t SPI_Transfer(uint8_t data);

#ifdef __cplusplus
}
#endif

#endif // SOFTWARE_SPI_H
```

### 驱动实现 `software_spi.c`
```c
#include "software_spi.h"

void SPI_Init(void) {
    // 初始化GPIO引脚（需用户实现）
    // 配置CS、MOSI、SCLK为输出，MISO为输入

    // 设置SCLK初始状态
#if (SPI_CPOL == 1)
    SCLK_HIGH();
#else
    SCLK_LOW();
#endif
}

/**
 * @brief 通过软件SPI传输一个字节并接收一个字节
 * @param data 要发送的数据字节
 * @return 通过MISO接收的数据字节
 */
uint8_t SPI_Transfer(uint8_t data) {
    uint8_t received = 0;
    for (int i = 0; i < 8; i++) {
        // 设置MOSI（MSB优先）
        if (data & (0x80 >> i)) {
            MOSI_HIGH();
        } else {
            MOSI_LOW();
        }

        // 生成时钟脉冲并采样MISO
#if (SPI_CPOL == 0)
    #if (SPI_CPHA == 0)
        SCLK_HIGH(); // 上升沿采样
        if (MISO_READ()) received |= (0x80 >> i);
        SCLK_LOW();
    #else // CPHA=1
        SCLK_HIGH();
        SCLK_LOW(); // 下降沿采样
        if (MISO_READ()) received |= (0x80 >> i);
    #endif
#else // CPOL=1
    #if (SPI_CPHA == 0)
        SCLK_LOW(); // 下降沿采样
        if (MISO_READ()) received |= (0x80 >> i);
        SCLK_HIGH();
    #else // CPHA=1
        SCLK_LOW();
        SCLK_HIGH(); // 上升沿采样
        if (MISO_READ()) received |= (0x80 >> i);
    #endif
#endif
    }
    return received;
}
```

### 示例程序 `main.c`
```c
#include "software_spi.h"

int main() {
    SPI_Init();

    // 示例：发送0xAA并接收数据
    CS_LOW();
    uint8_t received_data = SPI_Transfer(0xAA);
    CS_HIGH();

    // 其他操作...

    return 0;
}

/**
 * @brief 读取SPI设备的寄存器示例
 * @param reg_addr 寄存器地址
 * @return 寄存器的值
 */
uint8_t example_read_register(uint8_t reg_addr) {
    uint8_t reg_value;
    CS_LOW();
    SPI_Transfer(reg_addr); // 发送寄存器地址
    reg_value = SPI_Transfer(0xFF); // 发送哑数据，接收寄存器值
    CS_HIGH();
    return reg_value;
}
```

### 关键点说明
1. **模式支持**：通过`#if`条件编译处理四种SPI模式（CPOL和CPHA的组合）。
2. **时钟时序**：根据模式调整SCLK的高低电平和数据采样时机。
3. **引脚操作**：用户需根据硬件实现`CS/MOSI/MISO/SCLK`的宏定义。
4. **示例程序**：展示如何发送数据和读取寄存器，方便快速上手。

通过这种方式，代码灵活支持不同SPI模式，且结构清晰，便于维护和扩展。